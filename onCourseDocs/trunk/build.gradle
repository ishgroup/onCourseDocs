import org.apache.tools.ant.filters.ReplaceTokens
import java.time.LocalDate
import java.time.format.DateTimeFormatter

buildscript {
    repositories.maven {
        url 'https://repo.ish.com.au/content/groups/public'
    }
}

plugins {
    id 'com.github.ben-manes.versions' version '0.20.0' // adds the task 'dependencyUpdates'
    id 'distribution'
    id 'maven-publish'
}

apply plugin: 'groovy'

configurations {
    docbookxslt
}
repositories.maven {
    url 'https://repo.ish.com.au/content/groups/public'
}

dependencies {
    docbookxslt 'net.sf.docbook:docbook-xsl:1.79.1:resources@zip'
}
task explodeXSL(type: Copy) {
    from zipTree(configurations.docbookxslt.singleFile)
    into "${buildDir}/xslt"
}

subprojects {
    apply plugin: 'maven'
    apply plugin: 'maven-publish'
    apply plugin: 'distribution'
    apply plugin: 'com.github.ben-manes.versions'
    
    group = 'ish.oncourse.docs'
    version = project.hasProperty('releaseVersion') ? project.releaseVersion : 'SNAPSHOT'

    distributions {
        html {
            contents {
                from "${buildDir}/html"
            }
        }
        pdf {
            contents {
                from "${buildDir}/*.pdf"
            }
        }
    }
    uploadArchives.dependsOn htmlDistZip
    distTar.enabled = false

    publishing {
        publications {
            html(MavenPublication) {
                artifact htmlDistZip
            }
//            pdf(MavenPublication) {
//                artifact pdfDistZip
//            }
        }
        repositories {
            maven {
                name "snapshots"
                url "https://repo.ish.com.au/content/repositories/ish-snapshots"
                credentials {
                    username nexusUsername
                    password nexusPassword
                }
            }
            maven {
                name "releases"
                url "https://repo.ish.com.au/content/repositories/ish-releases"
                credentials {
                    username nexusUsername
                    password nexusPassword
                }
            }
        }
    }

    task processCommonSrc(type: Copy, dependsOn: parent.tasks['explodeXSL']) {
        from "${rootDir}/src"
        into "${buildDir}/processed"
        filter(ReplaceTokens,tokens: [
            canonicalLink: canonicalLink,
            rootDir: rootDir.absolutePath,
            buildDir: buildDir.absolutePath
        ])
    }

    task processSrc(type: Copy, dependsOn: processCommonSrc) {
        from "src"
        into "${buildDir}/processed"
        filter(ReplaceTokens,tokens: [
                projectName: project.name,
                version: version,
                publishedDate: LocalDate.now().format(DateTimeFormatter.ofPattern("d MMM yyyy")),
                copyrightYear : LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy"))
        ])
    }

    task docbookHtml(type: Docbook, dependsOn: processSrc) {
		description = 'Generates chunked docbook html output.'
        outputDirectory = file("${buildDir}/html")
        sourceDirectory = file("${buildDir}/processed")
        if (project.path == ":dsl") {
            stylesheet = file("${buildDir}/processed/stylesheets/api-html.xsl")
        } else if (project.path == ":release-notes") {
            stylesheet = file("${buildDir}/processed/stylesheets/release-html.xsl")
        } else {
            stylesheet = file("${buildDir}/processed/stylesheets/standard-html.xsl")
        }
        sourceImages = file("${projectDir}/src/images")
        sourceCss = file("${buildDir}/processed/css")
        sourceJs = file("${buildDir}/processed/js")
	}
    htmlDistZip.dependsOn(docbookHtml)

    task docbookPdfPrepare(type: Docbook, dependsOn: processSrc) {
        type = 'fo'
        description = 'Generates PDF fo output ready to be converted to pdf.'
        outputDirectory = file("${buildDir}/processed")
        stylesheet = file("${buildDir}/processed/stylesheets/pdf.xsl")
        sourceDirectory = file("${buildDir}/processed")
    }

	task docbookPdf(type: DocbookPdf, dependsOn: 'docbookPdfPrepare') {
		description = 'Generates PDF final output.'
        sourceDirectory = file("${buildDir}/processed")
        foFile = file("${sourceDirectory}/index.fo")
        fopConfFile = file("${sourceDirectory}/fonts/fop-conf.xml")
        outputFile = file("${buildDir}/${project.name}.pdf")
	}
    pdfDistZip.dependsOn(docbookPdf)

    task docbook(dependsOn: [docbookHtml, docbookPdf]) {
		group = 'Documentation'
		description = 'Generates all HTML and PDF documentation.'
	}

    // this task should be periodically run manually to optimise files in the source folders
    task optimise {
        description = "Optimise all the images"

        // both ImageMagick and optipng need to be installed
        doLast {
            fileTree("src").matching{ include '**/*.png' }.each{ f ->
                new ByteArrayOutputStream().withStream { resolution -> 
                    exec {
                        commandLine = 'magick'
                        standardOutput = resolution
                        args = ['identify', '-format', '%x', f.absolutePath]
                    }
                    if (resolution?.toString()?.isInteger() && resolution.toString() as Integer != 72) {
                        logger.warn('Found image {} which has resolution {}. Resizing now.', f.absolutePath, resolution.toString())
                        exec {
                            commandLine = 'convert'
                            args = [f.absolutePath, '-strip', '-units' ,'PixelsPerInch', '-resample', '72', f.absolutePath]
                        }
                    }
                }
                exec {
                    commandLine = 'optipng'
                    args = ['-fix', '-strip all', f.absolutePath]
                }
            }
        }
    }
}

// Skip beta and other non-final releases in the update report
dependencyUpdates.resolutionStrategy {
    componentSelection { rules ->
        rules.all { ComponentSelection selection ->
            boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm', 'preview', 'ea'].any { qualifier ->
                selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/
            }
            if (rejected) {
                selection.reject('Release candidate')
            }
        }
    }
}