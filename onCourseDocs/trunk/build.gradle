import org.apache.tools.ant.filters.ReplaceTokens
import java.time.LocalDate
import java.time.format.DateTimeFormatter

plugins {
    id 'com.github.ben-manes.versions' version '0.17.0' // adds the task 'dependencyUpdates'
    id 'java-gradle-plugin'
}

task buildScriptDependencies(type: DependencyReportTask) {
    configurations = project.buildscript.configurations
}

allprojects {
    version = project.hasProperty('docVersion') ? project.docVersion : 'unspecified'

    configurations {
        docbookxslt
    }

    repositories {
        maven {
            url 'https://repo.ish.com.au/content/groups/public'
        }
    }

    dependencies {
        docbookxslt 'net.sf.docbook:docbook-xsl:1.79.1:resources@zip'
    }

    task explodeXSL(type: Copy) {
        from zipTree(configurations.docbookxslt.singleFile)
        into "${buildDir}/xslt"
    }
}

subprojects {
    task processXSLT(type: Copy) {
        from "${rootDir}/stylesheets"
        into "${buildDir}/stylesheets"
        filter(ReplaceTokens,tokens: [
            canonicalLink: canonicalLink,
            rootDir: rootDir.absolutePath
        ])
    }

    task processSrc(type: Copy) {
        from "src"
        into "${buildDir}"
        filter(ReplaceTokens,tokens: [
                projectName: project.name,
                version: version,
                publishedDate: LocalDate.now().format(DateTimeFormatter.ofPattern("d MMM yyyy")),
                copyrightYear : LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy"))
        ])
    }

    task docbookHtml(type: Docbook, dependsOn: [processXSLT, processSrc, parent.tasks['explodeXSL']]) {
		description = 'Generates chunked docbook html output.'
        outputFile = file("${buildDir}/html/index.html")
        sourceDirectory = file("${projectDir}/src")
        if (project.path == ":apidocs") {
            stylesheet = file("${buildDir}/stylesheets/api-html.xsl")
        } else if (project.path == ":release-notes") {
            stylesheet = file("${buildDir}/stylesheets/release-html.xsl")
        } else {
            stylesheet = file("${buildDir}/stylesheets/standard-html.xsl")
        }
		
        sourceDirectory = file( "${buildDir}" )

        doLast {
            copy {
                into "${buildDir}/html/images"
                from "src/images"
            }
            copy {
                into "${buildDir}/html/css"
                from "${rootDir}/css"
            }
            copy {
                into "${buildDir}/html/js"
                from "${rootDir}/js"
            }
        }
	}

    task docbookPdfPrepare(type: Docbook, dependsOn: [processXSLT, processSrc, parent.tasks['explodeXSL']]) {
        description = 'Generates PDF fo output.'
        outputFile = file("${buildDir}/pdf/index.fo")
        stylesheet = file("${buildDir}/stylesheets/pdf.xsl")
        sourceDirectory = file("${projectDir}/src")
    }

	task docbookPdf(type: DocbookPdf, dependsOn: 'docbookPdfPrepare') {
		description = 'Generates PDF final output.'
        foFile = file("${buildDir}/pdf/index.fo")
        sourceDirectory = file("${projectDir}/src")
        outputFile = file("${buildDir}/pdf/${project.name}.pdf")
	}

	task docbook(dependsOn: [docbookHtml, docbookPdf]) {
		group = 'Documentation'
		description = 'Generates all HTML and PDF documentation.'
	}

    // this task should be periodically run manually to optimise files in the source folders
    task optimise {
        description = "Optimise all the images"

        // both ImageMagick and optipng need to be installed
        doLast {
            fileTree("src").matching{ include '**/*.png' }.each{ f ->
                new ByteArrayOutputStream().withStream { resolution -> 
                    exec {
                        commandLine 'magick'
                        standardOutput = resolution
                        args 'identify', '-format', '%x', f.absolutePath
                    }
                    if (resolution?.toString()?.isInteger() && resolution.toString() as Integer != 72) {
                        logger.warn('Found image {} which has resolution {}. Resizing now.', f.absolutePath, resolution.toString())
                        exec {
                            commandLine 'convert'
                            args f.absolutePath, '-strip', '-units' ,'PixelsPerInch', '-resample', '72', f.absolutePath
                        }
                    }
                }
                exec {
                    commandLine 'optipng'
                    args '-fix', '-strip all', f.absolutePath
                }
            }
        }
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '4.3.1'
}