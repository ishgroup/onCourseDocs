import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import groovy.xml.MarkupBuilder
import groovy.swing.SwingBuilder

task mergeImages(type: Copy) {
    from fileTree(dir: 'src', include: '**/images/*').files
    into "${buildDir}/html/images"
    includeEmptyDirs = false
}
docbookHtml.dependsOn mergeImages
docbookPdf.dependsOn mergeImages


// Run the following task to create new release notes from squish
task releaseNotes(type: ReleaseNotes) {
  description = 'Generate new release notes.'
}

class ReleaseNotes extends DefaultTask {

  @TaskAction
  def getNotes() {

    def jiraUsername = ''
    def jiraPassword = ''
    def jiraFixVersion = ''
    new SwingBuilder().edt {
      dialog(modal: true,
              title: 'Enter password',
              alwaysOnTop: true,
              resizable: false,
              locationRelativeTo: null, // Place dialog in center of the screen
              pack: true,
              show: true
      ) {
        vbox {
          label(text: "Enter your squish username:")
          input_user = textField()
          label(text: "Enter your squish password:")
          input_pass = passwordField()
          label(text: "Which version of onCourse are you releasing:")
          input_version = textField()
          button(defaultButton: true, text: 'OK', actionPerformed: {
            jiraUsername = input_user.text
            jiraPassword = input_pass.password.toString()
            jiraFixVersion = input_version.text
            dispose()
          })
        }
      }
    }

    logger.lifecycle "Getting issues..."

    // https://docs.atlassian.com/jira/REST/latest/#idp1389824
    def SQUISH_URL = "https://squish.ish.com.au/rest/api/latest/search"
    def query = "?jql=resolution+in+(closed,Unresolved)+and+fixVersion=${jiraFixVersion}&maxResults=1000"
    def encoded_auth = "$jiraUsername:$jiraPassword".getBytes().encodeBase64().toString()

    logger.lifecycle "Getting " + (SQUISH_URL + query).toURL()
    def connection = (SQUISH_URL + query).toURL().openConnection()
    connection.addRequestProperty("Authorization", "Basic ${encoded_auth}")
    connection.addRequestProperty("Content-Type", "application/json")
    connection.setRequestMethod("GET")
    connection.doOutput = false
    connection.connect()

    def slurper = new JsonSlurper()
    def json_data = slurper.parseText(connection.content.text)
    logger.debug new JsonBuilder(json_data).toPrettyString()

    logger.lifecycle "Found ${json_data.issues.size()} issues..."
    buildDocBook(jiraFixVersion, json_data.issues)

  }

  def buildDocBook(version, issues) {
    issues.sort { issue -> issue.key }
    issues.each { issue ->
      logger.lifecycle issue.key + " " + issue.fields.summary
    }
    def issues_reports, issues_web, issues_angel
    def WEB_APPS = ['Web', 'Enrol', 'CMS', 'Portal', 'Search']
    (issues_web, issues_angel) = issues.split { issue -> issue.fields.components.any { WEB_APPS.contains(it.name) } }
    (issues_reports, issues_angel) = issues_angel.split { issue -> issue.fields.summary.contains('report') }

    def subdir = new File(project.projectDir, "/src/" + version)
    subdir.mkdirs()
    def imagesDir = new File(subdir, "images")
    imagesDir.mkdirs()

    def fw = new FileWriter(new File(subdir, "release-notes.xml"))
    def xml = new MarkupBuilder(fw)
    xml.mkp.xmlDeclaration(version: "1.0", encoding: "utf-8")

    xml.chapter('xmlns': 'http://docbook.org/ns/docbook', 'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
            'xsi:schemaLocation': 'http://docbook.org/ns/docbook file://../../src/docbook.xsd',
            'xmlns:xlink': 'http://www.w3.org/1999/xlink', version: '5.0', 'xml:id': "release-${version}") {
      info {
        title("Release ${version}")
        pubdate(new Date().format('d MMM yyyy'))
      }
      section(role: 'important') {
        title("Important changes")
        para(' ')
      }
      section(role: 'major') {
        title("Major features")
        para(' ')
      }
      section(role: 'scripts') {
        title("Reports and scripts")
        itemizedlist {
          issues_reports.each { issue ->
            listitem {
              para {
                mkp.yield(issue.fields.summary)
                systemitem(issue.key)
              }
            }
          }
        }
        section(role: 'minor') {
          title("Minor features")
          itemizedlist {
            issues_angel.findAll { issue -> issue.fields.issuetype.name != "Defect" }.each { issue ->
              listitem {
                para {
                  mkp.yield(issue.fields.summary)
                  systemitem(issue.key)
                }
              }
            }
          }
        }
        section(role: 'fixes') {
          title("Fixes")
          itemizedlist {
            issues_angel.findAll { issue -> issue.fields.issuetype.name == "Defect" }.each { issue ->
              listitem {
                para {
                  mkp.yield(issue.fields.summary)
                  systemitem(issue.key)
                }
              }
            }
          }
        }
        section(role: 'web') {
          title("Web features")
          itemizedlist {
            issues_web.findAll { issue -> issue.fields.issuetype.name != "Defect" }.each { issue ->
              listitem {
                para {
                  mkp.yield(issue.fields.summary)
                  systemitem(issue.key)
                }
              }
            }
          }
        }
        section(role: 'web-fixes') {
          title("Web fixes")
          itemizedlist {
            issues_web.findAll { issue -> issue.fields.issuetype.name == "Defect" }.each { issue ->
              listitem {
                para {
                  mkp.yield(issue.fields.summary)
                  systemitem(issue.key)
                }
              }
            }
          }
        }
      }
    }
  }
}