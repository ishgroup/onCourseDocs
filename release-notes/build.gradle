import groovy.xml.MarkupBuilder
import groovyx.net.http.ContentType
import groovyx.net.http.RESTClient
import groovyx.net.http.HttpResponseException
import org.apache.tools.ant.filters.ReplaceTokens

import java.time.LocalDate
import java.time.format.DateTimeFormatter

buildscript {
  repositories.maven {
    url 'https://repo.ish.com.au/content/groups/public'
  }
  dependencies {
    classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.2'
  }
}

task createIndex(type: Copy, dependsOn: processSrc) {
  def versions = file('src').listFiles().collect{it.name}.findAll{ it[0].isNumber() }
  versions.sort() { a, b ->

    List verA = a.tokenize('.')
    List verB = b.tokenize('.')

    def commonIndices = Math.min(verA.size(), verB.size())

    for (int i = 0; i < commonIndices; ++i) {
      def numA = verA[i] as int
      def numB = verB[i] as int
      if (numA != numB) {
        return numA <=> numB
      }
    }
    // If we got this far then all the common indices are identical, so whichever version is longer must be more recent
    verA.size() <=> verB.size()
  }

  from "src/index.xml"
  into "${buildDir}/processed"
  filter(ReplaceTokens,tokens: [
          versions: versions.reverse().collect { "<xi:include href='${it}/release-notes.xml'/>" }.join('\n\t\t\t\t'),
          publishedDate: LocalDate.now().format(DateTimeFormatter.ofPattern("d MMM yyyy")),
          copyrightYear : LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy"))
  ])
}
docbookHtml.dependsOn createIndex
docbookPdf.dependsOn createIndex

task mergeImages(type: Copy) {
    from fileTree(dir: 'src', include: '**/images/*').files
    into "${buildDir}/html/images"
    includeEmptyDirs = false
}
docbookHtml.dependsOn mergeImages
docbookPdf.dependsOn mergeImages


// Run the following task to create new release notes from squish
// ./gradlew release-notes:releaseNotes -PreleaseVersion=1.1
task releaseNotes(type: ReleaseNotes) {
  if (project.hasProperty('releaseVersion')) {
  	version = releaseVersion
  }
  outputFile = new File(project.projectDir, "/src/${version}/release-notes.xml")
}

class ReleaseNotes extends DefaultTask {
  @Input
  String version

  @OutputFile
  def outputFile

  @TaskAction
  def getNotes() {
    def issues = getJiraResponse("resolution in (closed,Unresolved) and fixVersion=${version}").issues as Collection

    logger.lifecycle "Found ${issues.size()} issues..."

    outputFile.parentFile.mkdirs()
    new File(outputFile.parentFile, "images").mkdirs()

    buildDocBook(version, issues, outputFile)
  }

  def getJiraResponse(jql) {
    // https://developer.atlassian.com/cloud/jira/platform/rest/
    def squish = new RESTClient('https://squish.ish.com.au', ContentType.JSON)
    // The following line is needed instead of squish.auth.basic since we need to pre-emptive auth
    squish.headers.'Authorization' = "Basic ${"gradle:7Am1*^X8A#ul".bytes.encodeBase64().toString()}"
    try {
      def response = squish.get(
              path: '/rest/api/2/search',
              query: [jql: jql, maxResults: '1000'])
      return response.data

    } catch(HttpResponseException e) {
      logger.error "*** Request to squish failed with error: ${e.response.data}"
    }
  }

  def buildDocBook(version, Collection issues, File outputFile) {
    issues.sort { issue -> issue.key }
    issues.each { issue ->
      logger.lifecycle issue.key + " " + issue.fields.summary
    }
    def issues_reports, issues_web, issues_angel
    def WEB_APPS = ['Web', 'Enrol', 'CMS', 'Portal', 'Search']
    (issues_web, issues_angel) = issues.split { issue -> issue.fields.components.any { WEB_APPS.contains(it.name) } }
    (issues_reports, issues_angel) = issues_angel.split { issue -> issue.fields.summary.contains('report') }

    def xml = new MarkupBuilder(new FileWriter(outputFile))
    xml.mkp.xmlDeclaration(version: "1.0", encoding: "utf-8")

    xml.chapter('xmlns': 'http://docbook.org/ns/docbook', 'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
            'xsi:schemaLocation': 'http://docbook.org/ns/docbook file://../../src/docbook.xsd',
            'xmlns:xlink': 'http://www.w3.org/1999/xlink', version: '5.0', 'xml:id': "release-${version}") {
      info {
        title("Release ${version}")
        pubdate(new Date().format('d MMM yyyy'))
      }
      section(role: 'important') {
        title("Important changes")
        para(' ')
      }
      section(role: 'major') {
        title("Major features")
        para(' ')
      }
      section(role: 'scripts') {
        title("Reports and scripts")
        itemizedlist {
          issues_reports.each { issue ->
            listitem {
              para {
                mkp.yield(issue.fields.summary)
                systemitem(issue.key)
              }
            }
          }
        }
      }
      section(role: 'minor') {
        title("Minor features")
        itemizedlist {
          issues_angel.findAll { issue -> issue.fields.issuetype.name != "Defect" }.each { issue ->
            listitem {
              para {
                mkp.yield(issue.fields.summary)
                systemitem(issue.key)
              }
            }
          }
        }
      }
      section(role: 'fixes') {
        title("Fixes")
        itemizedlist {
          issues_angel.findAll { issue -> issue.fields.issuetype.name == "Defect" }.each { issue ->
            listitem {
              para {
                mkp.yield(issue.fields.summary)
                systemitem(issue.key)
              }
            }
          }
        }
      }
      section(role: 'web') {
        title("Web features")
        itemizedlist {
          issues_web.findAll { issue -> issue.fields.issuetype.name != "Defect" }.each { issue ->
            listitem {
              para {
                mkp.yield(issue.fields.summary)
                systemitem(issue.key)
              }
            }
          }
        }
      }
      section(role: 'web-fixes') {
        title("Web fixes")
        itemizedlist {
          issues_web.findAll { issue -> issue.fields.issuetype.name == "Defect" }.each { issue ->
            listitem {
              para {
                mkp.yield(issue.fields.summary)
                systemitem(issue.key)
              }
            }
          }
        }
      }
    }
  }
}
